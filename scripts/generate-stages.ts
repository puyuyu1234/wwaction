/**
 * ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿è‡ªå‹•ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * stages/*.json ã¨ stageMetadata.ts ã‚’çµ±åˆã—ã¦ src/game/stages.ts ã‚’ç”Ÿæˆ
 */

import { readdirSync, readFileSync, writeFileSync } from 'fs'
import { join } from 'path'

const stagesDir = join(process.cwd(), 'stages')
const metadataFile = join(process.cwd(), 'scripts/stageMetadata.ts')
const outputFile = join(process.cwd(), 'src/game/stages.ts')

console.log('ğŸ”„ Generating stages.ts from JSON files and metadata...')

// stages/*.json ã‚’èª­ã¿è¾¼ã¿
const files = readdirSync(stagesDir)
  .filter((f: string) => f.match(/^stage-\d{2}\.json$/))
  .sort()

if (files.length === 0) {
  console.error('âŒ No stage-XX.json files found in stages/ directory')
  process.exit(1)
}

// å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ã‚°ãƒªãƒƒãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—å½¢å¼ï¼‰
const grids: string[][][] = []
files.forEach((file: string) => {
  const json = readFileSync(join(stagesDir, file), 'utf-8')
  const parsed = JSON.parse(json) as string[][]
  grids.push(parsed)
})

// stageMetadata.tsã‚’èª­ã¿è¾¼ã¿
const metadataContent = readFileSync(metadataFile, 'utf-8')

// 1. importæ–‡ã‚’æŠ½å‡º
const imports: string[] = []
const importRegex = /^import\s+.*$/gm
let match
while ((match = importRegex.exec(metadataContent)) !== null) {
  imports.push(match[0])
}

// 2. STAGE_METADATAã‚’æŠ½å‡º
const metadataMatch = metadataContent.match(
  /export const STAGE_METADATA[^=]*=\s*(\[[^]*?\n\])/
)
if (!metadataMatch) {
  console.error('âŒ Could not parse STAGE_METADATA from stageMetadata.ts')
  process.exit(1)
}

// 3. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’JavaScriptã¨ã—ã¦è©•ä¾¡
const metadataArrayStr = metadataMatch[1]
// DekaNasakeãªã©ã®ã‚¯ãƒ©ã‚¹å‚ç…§ã‚’ä¸€æ™‚çš„ã«æ–‡å­—åˆ—åŒ–ã—ã¦è©•ä¾¡
const metadataForEval = metadataArrayStr.replace(/:\s*([A-Z]\w+),/g, ': "$1",')
 
const metadata = new Function(`return ${metadataForEval}`)() as Array<{
  name?: string
  engName?: string
  bgm?: string
  bg: string[]
  fg: string[]
  param?: { boss: string }
}>

if (metadata.length !== grids.length) {
  console.error(
    `âŒ Mismatch: ${metadata.length} metadata entries vs ${grids.length} stage files`
  )
  process.exit(1)
}

// 4. StageData[]é…åˆ—ã‚’ä½œæˆï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ + ã‚°ãƒªãƒƒãƒ‰çµ±åˆï¼‰
const stageData = metadata.map((meta, index) => ({
  ...meta,
  stages: grids[index], // grids[index]ã¯æ—¢ã«string[][]ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—ï¼‰
}))

// 5. JSONåŒ–
const stageDataJSON = JSON.stringify(stageData, null, 2)

// 6. ã‚¯ãƒ©ã‚¹å‚ç…§ã‚’å¾©å…ƒï¼ˆ"boss": "ClassName" â†’ "boss": ClassNameï¼‰
const stageDataCode = stageDataJSON.replace(/"boss":\s*"(\w+)"/g, '"boss": $1')

// 7. TypeScriptã‚³ãƒ¼ãƒ‰ã¨ã—ã¦å‡ºåŠ›
const output = `/**
 * ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-stages.ts
 * stages/*.json + scripts/stageMetadata.ts ã‚’çµ±åˆ
 */

import type { StageData } from './types'

${imports.join('\n')}

export const STAGEDATA: StageData[] = ${stageDataCode}
`

// ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
writeFileSync(outputFile, output, 'utf-8')

console.log(`âœ… Generated ${files.length} stages -> ${outputFile}`)
